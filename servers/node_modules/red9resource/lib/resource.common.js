var _ = require('underscore')._;
var async = require('async');
var VError = require('verror');
var moment = require('moment');
var validator = require('validator');

var logger = require('red9logger');

/**
 * Generates a GUID string, according to RFC4122 standards.
 *
 * Modified by SRLM to generate a version 4 UUID.
 *
 * @returns {String} The generated GUID.
 * @example af8a8416-6e18-a307-bd9c-f2c947bbb3aa
 * @author Slavik Meltser (slavik@meltser.info).
 * @link http://slavik.meltser.info/?p=142
 */
exports.generateUUID = function () {
    function _p8() {
        return (Math.random().toString(16) + "000000000").substr(2, 8);
    }

    var setB = _p8();
    var setC = _p8();

    var t = ['8', '9', 'a', 'b'];
    var single = t[Math.floor(Math.random() * t.length)];

    return _p8() + '-' + setB.substr(0, 4) + '-4' + setB.substr(4, 3) + '-'
        + single + setC.substr(0, 3) + '-' + setC.substr(4, 4) + _p8();
};

function getMap(mapping, jsKey) {
    return _.find(mapping, function (value) {
        return value.jsKey === jsKey;
    });
}

/**
 *
 * @param tableName
 * @param mapping
 * @param query Array of ANDed conditions
 * @returns {{query: string, parameters: Array, hints: Array}}
 */
exports.constructWhereQueryWithParameters = function (tableName, mapping, query) {
    var result = '';
    var parameters = [];
    var hints = [];

    _.each(query, function (condition) {
        var key = Object.keys(condition)[0];
        var parameter = condition[key];
        if (result !== '') {
            // We have multiple constraints
            result += ' AND ';
        }

        var map = getMap(mapping, key);

        if (_.isObject(parameter)) {
            // $in condition
            if (Object.keys(parameter).length === 1
                && _.has(parameter, '$in')) {
                // This is a hacky way to get a series of "?,?,?" and array values
                result += map.cassandraKey + ' IN (' + _.reduce(parameter.$in, function (memo, value) {
                    if (memo !== '') { // if not first
                        memo += ',';
                    }
                    memo += '?';
                    parameters.push(convertJSTypeToCassandraType(value, map.jsType, map.cassandraType));
                    hints.push(map.cassandraType);
                    return memo;
                }, '') + ')';


            } else {
                logger.error('could not parse parameter ' + JSON.stringify(parameter));
            }

        } else if (_.isArray(parameter)) {
            logger.error('array parameters are not supported on non command keys');
        } else if (_.isString(parameter) || _.isNumber(parameter) || _.isBoolean(parameter)) {
            if (map.cassandraType.indexOf('set') === 0) {
                result += map.cassandraKey + ' CONTAINS ?';
                parameters.push([parameter]);
            } else {
                result += map.cassandraKey + '=?';
                parameters.push(parameter);
            }

            hints.push(map.cassandraType);
        } else {
            logger.error('can not parse the parameter for key ' + key);
        }
    });

    if (result !== '') {
        // Only add the WHERE clause if we have something to filter by.
        result = ' WHERE ' + result;
    }

    var queryString = 'SELECT * FROM '
        + tableName + result + ' ALLOW FILTERING';
    return {
        query: queryString,
        parameters: parameters,
        hints: hints
    };
};

exports.mapToResource = function (mapping, cassandraResource) {
    var result = {};
    _.each(mapping, function (map) {
        if (_.has(cassandraResource, map.cassandraKey)) {
            result[map.jsKey] = convertCassandraTypeToJSType(cassandraResource[map.cassandraKey],
                map.jsType,
                map.cassandraType
            );
        }
    });
    return result;
};

/**
 *
 * @param query
 * @returns {{cassandra: Array, local: Object}} cassandra is an array of AND conditions
 */
exports.divideQueries = function (query) {
    var cassandra = [];
    var local = {};

    _.each(query, function (value, key) {
        if (isEmbeddedDocument(key)) {
            // Embedded document
            // We need to test this early in case it's value is a simple string
            local[key] = value;
        } else if (_.isString(value) || _.isNumber(value)) {
            // Basic equality test here
            var t = {};
            t[key] = value;
            cassandra.push(t);
        } else if (_.isObject(value)
            && _.keys(value).length === 1
            && _.has(value, '$in')) {
            // $in object, which we can do in cassandra
            var t = {};
            t[key] = value;
            cassandra.push(t);
        } else if (key === '$and') {
            _.each(value, function (condition) {
                var conditionKey = Object.keys(condition)[0];
                var conditionValue = condition[conditionKey];
                if (_.isString(conditionValue) || _.isNumber(conditionValue)) { // Simple value. A bit of duplicate code, but quick.
                    cassandra.push(condition);
                } else {
                    if (!_.has(local['$and'])) {
                        local['$and'] = [];
                    }
                    local['$and'].push(condition);
                }
            });
        } else {
            local[key] = value;
        }
    });

    var result = {
        cassandra: cassandra,
        local: local
    };
    //console.dir(result);
    return result;
};


/** Test query against a value.
 *
 * @param resource {object} The full resource that we need to test
 * @param queryKey {string} the key. Supported keys are $and, $or, and the resource keys themselves (for ===)
 * @param query {object} The query should be an object with keys selected from:
 *                          $gt, $gte, $lt, $lte, $ne.
 *                          The query should be just the constraints. So, something like this:
 *                          {$gt: 53, $lt: 100, $ne: 75}
 *
 *                          $or, $and can have at most one internal condition
 *
 *                          Multiple constraints are ANDed together.
 *
 *                          If the query is not an object then it is tested directly for equality.
 *
 * @returns {boolean} true if resource passes, false otherwise. Defaults to false.
 */
function testQueryOnValue(resource, queryKey, query) {
    //console.log('test query on value: ')
    //console.log(queryKey)
    //console.dir(query);

    var value = extractValue(queryKey, resource);
    //console.dir(value);


    if (_.isObject(query) === false) {
        // then we want to do an equality comparison
        return value === query;
    }

    // At this point we know the query is a more complex object, and we're
    // doing a non-equality comparison
    if (_.isArray(query) && query.length > 1) {
        // Multiple constraints are ANDed together.
        function setupRecursiveCall(condition, index) {
            var tempKey = Object.keys(condition)[0];
            var tempValue = condition[tempKey];
            var t = testQueryOnValue(resource, tempKey, tempValue);
            return t;
        }
        if (queryKey === '$or') {
            return _.any(query, setupRecursiveCall);
        }
        if (queryKey === '$and') {
            return _.every(query, setupRecursiveCall);
        }
    }
    // else testing a single condition

    if (_.has(query, '$gt')) {
        return value > query.$gt;
    } else if (_.has(query, '$lt')) {
        return value < query.$lt;
    } else if (_.has(query, '$gte')) {
        return value >= query.$gte;
    } else if (_.has(query, '$lte')) {
        return value <= query.$lte;
    } else if (_.has(query, '$ne')) {
        return value !== query.$ne;
    } else {
        return false;
    }
}

function isEmbeddedDocument(key) {
    return key.indexOf('.') !== -1;
}

/**
 *
 * @param key {string} a dot separated path
 * @param resource {object} the object from which to extract the value
 * @returns {non-object or array value} Returns the value if found. If not found or result would not be a simple value then returns undefined.
 */
function extractValue(key, resource) {
    if (typeof resource === 'undefined') {
        return undefined;
    }

    var path = key.split('.');
    var value = resource[path[0]];

    if (path.length > 1) {
        return extractValue(path.slice(1).join('.'), value);
    } else if (_.isArray(value) || _.isObject(value)) {
        // Must be after recursive test.
        return undefined;
    } else {
        return value;
    }
}

/** This tests "local" query constraint against a resource. Tested constraints are:
 *
 * @todo(SRLM) equality for array element [NOT IMPLEMENTED]
 * @todo(SRLM) add in $in, $nin operators (mostly useful for arrays and embedded documents)
 * @todo(SRLM) add in logical operators $or, $and, $not, $nor
 *
 * embedded document comparison (must be of the format "nested.keys.are.dot.separated" and not as nested objects)
 * comparison operators ([equal], $gt, $gte, $lt, $lte, $ne)
 *
 * @param resource the resource to test against
 * @param query {object} the mongoDB style query. Empty {} for no query.
 * @returns {boolean} true if the document satisfies the query, false otherwise
 */
exports.testAgainstQuery = function (resource, query) {
    return _.all(query, function (queryParameter, queryKey) {
        return testQueryOnValue(resource, queryKey, queryParameter);
    });
};


// -------------------------------------------------------------------------
// Pipeline components
// -------------------------------------------------------------------------
/** Create an ordering object.
 *
 * @param parameters {object} mongoDB style order by: {key: 1} (ascending) or {key2: -1} (descending) or {key3: 0} (no orderBy)
 * @param next {function} (resource) the next stage to call with a resource
 * @returns {{newRow: newRow, done: done}} two functions: call newRow with each row of data, and done when done.
 */
function setupOrderBy(parameters, next) {
    // Get rid of the "no" orderBy parameters (0):
    parameters = _.reduce(parameters, function (memo, value, key) {
        if (value !== 0) {
            memo[key] = value;
        }
        return memo;
    }, {});


    // If we're ordering we'll store the items here for eventual sorting.
    var list = [];

    // We're ordering if the orderBy parameters have exactly one key
    var amOrdering = _.keys(parameters).length === 1;
    if (_.keys(parameters).length > 1) {
        logger.error('Too many orderBy keys. Defaulting to no orderBy.');
        amOrdering = false;
    }

    var sortingKey;
    if (amOrdering) {
        sortingKey = _.keys(parameters)[0];
    }

    function sortingFunction(e) {
        // Multiply to get the correct sorting direction.
        return e[sortingKey] * parameters[sortingKey];
    }

    return {
        newRow: function (e) {
            if (amOrdering) {
                list.push(e);
            } else {
                next(e);

            }
        },
        done: function () {
            if (amOrdering) {
                _.chain(list)
                    .sortBy(sortingFunction)
                    .each(function (e) {
                        next(e);
                    });
            }
            // If we're not orderBy-ing then we don't have to do anything at the end:
            // we've already sent the results
        }
    };
}

/**
 *
 * @param $skip
 * @param $limit Limit the response to this number of items. Set to undefined or 0
 * @param postQueue
 * @returns {Function}
 */
function setupSkipAndLimit($skip, $limit, postQueue) {

    if (typeof $skip === 'undefined'
        || $skip === null
        || _.isNumber($skip) === false
        || $skip < 0) {
        $skip = 0;
    }

    if (typeof $limit === 'undefined'
        || $skip === null
        || _.isNumber === false
        || $limit <= 0) {
        $limit = Number.MAX_VALUE;
    }

    return function (e) {
        if ($skip > 0) {
            $skip--;
        } else if ($limit <= 0) {
            // do nothing
        } else {
            $limit--;
            postQueue.push(e);
        }
    };
}

/**
 *
 * @param extraParameters
 * @param expandFunction
 * @param rowCallback
 * @param callback (err, rowCount)
 * @returns {{row: row, done: done}}
 */
exports.queryTailPipeline = function (extraParameters, expandFunction, rowCallback, callback) {
    if (!extraParameters) {
        extraParameters = {};
    }
    if (!_.isFunction(expandFunction)) {
        expandFunction = function (t, resource, call) {
            call(null, resource);
        };
    }

    var resultRowCount = 0;
    var expandQueue = async.queue(function (resource, queueCallback) {
        //expand resource;
        expandFunction(extraParameters.$expand, resource, function (err, expandedResource) {
            rowCallback(expandedResource);
            resultRowCount++;
            queueCallback();
        });
    }, 1);

    var skipAndLimit = setupSkipAndLimit(extraParameters.$skip, extraParameters.$limit, expandQueue);
    var orderBy = setupOrderBy(extraParameters.$orderBy, skipAndLimit);
    return {
        row: function (row) {
            orderBy.newRow(row);
        },
        done: function () {
            orderBy.done();
            if (expandQueue.idle()) {
                callback(null, resultRowCount);
            } else {
                expandQueue.drain = function () {
                    callback(null, resultRowCount);
                };
            }
        }
    };
};

// -------------------------------------------------------------------------
// Create Resource
// -------------------------------------------------------------------------
/**
 *
 * @param value
 * @param jsType
 * @param cassandraType
 * @returns {*} if value is null, returns undefined
 */
function convertCassandraTypeToJSType(value, jsType, cassandraType) {
    if (_.isNull(value)) {
        return; // undefined
    }

    if (jsType === 'object' && cassandraType === 'varchar') {
        try {
            return JSON.parse(value);
        } catch (e) {
            return {};
        }
    }

    if (jsType === 'object' && _.isObject(value)) { // cassandraType map<***, ***>
        return value;
    }

    if (jsType === 'array' && _.isArray(value)) { // cassandraType set<***> or list<***>
        return value;
    }

    if (jsType === 'timestamp' && cassandraType === 'timestamp') {
        if (_.isDate(value)) {
            return value.getTime();
        } else if (_.isNumber(value)) {
            // This isNumber condition is a bit bogus. It's pretty much here just to make
            // the unit tests pass, since nodejs-driver for cassandra always returns timestamps
            // as dates.
            return value;
        } else {
            throw new VError('Programmer error: bad type for timestamp: %s', typeof value);
        }
    }


    return value;
}

function convertJSTypeToCassandraType(value, jsType, cassandraType) {
    if (_.isObject(value) && jsType === 'object' && cassandraType === 'varchar') {
        return JSON.stringify(value);
    }

    if (_.isArray(value) && jsType === 'array' && cassandraType === 'varchar') {
        return JSON.stringify(value);
    }

    return value;
}

exports.createResourceQuery = function (tableName, mapping, newResource) {
    var result = _.reduce(mapping, function (memo, map, index) {
            if (_.has(newResource, map.jsKey)) {
                if (memo.keys !== '') { // if not first
                    memo.keys += ',';
                    memo.parameterPlaceholders += ',';
                }

                memo.keys += map.cassandraKey;
                memo.parameterPlaceholders += '?';
                memo.parameters.push(convertJSTypeToCassandraType(newResource[map.jsKey], map.jsType, map.cassandraType));
                memo.hints.push(map.cassandraType);
            }
            return memo;
        },
        {
            keys: '',
            parameterPlaceholders: '',
            parameters: [],
            hints: []
        }
    );
    result.query = 'INSERT INTO ' + tableName + ' (' + result.keys + ') VALUES (' + result.parameterPlaceholders + ')';


    return {
        query: result.query,
        parameters: result.parameters,
        hints: result.hints
    };
};

exports.createUpdateQuery = function (tableName, id, mapping, updatedResource) {
    var result = _.reduce(mapping, function (memo, map, index) {
            if (_.has(updatedResource, map.jsKey)) {
                if (memo.assignments !== '') { // if not first
                    memo.assignments += ',';
                }

                memo.assignments += map.cassandraKey + '=?';
                memo.parameters.push(convertJSTypeToCassandraType(updatedResource[map.jsKey], map.jsType, map.cassandraType));
                memo.hints.push(map.cassandraType);
            }
            return memo;
        },
        {
            assignments: '',
            parameters: [],
            hints: []
        }
    );
    result.query = 'UPDATE ' + tableName + ' SET ' + result.assignments + ' WHERE id=' + id;

    return {
        query: result.query,
        parameters: result.parameters,
        hints: result.hints
    };
};

exports.createDeleteString = function (tableName, id) {
    return 'DELETE FROM ' + tableName + ' WHERE id = ' + id;
};


// Testing exports
exports.testQueryOnValue = testQueryOnValue;
exports.extractValue = extractValue;
exports.setupSkipAndLimit = setupSkipAndLimit;
exports.setupOrderBy = setupOrderBy;