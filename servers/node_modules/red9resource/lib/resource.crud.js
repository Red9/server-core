var moment = require('moment');
var common = require('./resource.common.js');
var cassandra = require('./cassandra');
var _ = require('underscore')._;
var VError = require('verror');

/**
 *
 * @todo: there's a bug here: if I pass in an object with extra keys it all get's returned, even if some haven't been actually stored.
 *
 * @param resourceDescription
 * @param newResource
 * @param callback {err, ???}
 */
exports.create = function (resourceDescription, newResource, callback, deepMigrate) {
    if (_.isFunction(resourceDescription.populateDefaults)) {
        resourceDescription.populateDefaults(newResource);
    }
    // We're not going to check. Assume that all input is valid.

    // Every resource gets an ID
    if (deepMigrate !== true) {
        newResource.id = common.generateUUID();
        newResource.createTime = moment().valueOf();
    }

    if (_.isFunction(resourceDescription.populateOnCreate)) {
        resourceDescription.populateOnCreate(newResource);
    }

    resourceDescription.checkResource(newResource, function (err, finalResource) {
        if (err) {
            callback(err);
            return;
        }

        var t = common.createResourceQuery(resourceDescription.tableName, resourceDescription.mapping, finalResource);

        cassandra.execute({
            query: t.query,
            parameters: t.parameters,
            hints: t.hints,
            callback: function (err) {
                if (err !== null) {
                    callback(err);
                } else {
                    callback(null, finalResource);
                }
            }
        });
    });
};

/**
 *
 * @param query
 * @param options
 * @param rowCallback
 * @param callback (err, totalRows)
 */
exports.find = function (resourceDescription, query, options, rowCallback, callback) {
    var dividedQuery;
    var pipeline;

    if (typeof options === 'undefined') {
        options = {};
    }
    if (!_.isFunction(rowCallback)) {
        rowCallback = function () {
        };
    }
    if (!_.isFunction(callback)) {
        throw new VError('must define a callback function');
    }
    dividedQuery = common.divideQueries(query);

    var cassandraQuery = common.constructWhereQueryWithParameters(resourceDescription.tableName,
        resourceDescription.mapping, dividedQuery.cassandra);

    pipeline = common.queryTailPipeline(options, resourceDescription.expand, rowCallback, callback);

    cassandra.execute({
        query: cassandraQuery.query,
        parameters: cassandraQuery.parameters,
        hints: cassandraQuery.hints,
        rowCallback: function (cassandraResource) {
            var resource = common.mapToResource(resourceDescription.mapping, cassandraResource);
            // var resource = resourceDescription.mapToResource(cassandraResource);
            if (_.isFunction(resourceDescription.populateDynamic)) {
                resource = resourceDescription.populateDynamic(resource);
            }

            if (common.testAgainstQuery(resource, dividedQuery.local)) {
                pipeline.row(resource);
            }
        },
        callback: function (err) {
            if (err) {
                callback(err);
            } else {
                // At this point the pipeline will call the done callback
                pipeline.done();
            }
        }

    });

};

/**
 *
 * Some invalid updates are silently discared. Invalid updates include
 * - Update non-editable key
 * - Update non-existant key
 *
 * @param find
 * @param resourceDescription
 * @param id
 * @param updatedResource
 * @param callback
 */
exports.update = function (find, resourceDescription, id, updatedResource, callback) {
    // Check to make sure that the resource exists
    // And store it so we can validate the updated resource
    var resourceTemp;
    find({id: id}, null,
        function (foundResource) {
            resourceTemp = foundResource;
        },
        function (err, rowCount) {
            if (err) {
                callback(err);
            } else if (rowCount !== 1) {
                callback(new VError('%s %s does not exist (%s results found)', resourceDescription.tableName, id, rowCount));
            } else {
                var completeUpdatedResource = _.extend(resourceTemp, updatedResource);
                resourceDescription.checkResource(completeUpdatedResource, function (err, finalResource) {
                    if (err) {
                        callback(err);
                    } else {
                        // Test to make sure there's something to update. Ideally, we would have this
                        // somewhere up above, but we need to get the new values for the
                        // created resource.
                        delete finalResource.id; // Make sure we don't try to update the key, if it has it...
                        var updateQuery = common.createUpdateQuery(resourceDescription.tableName, id, resourceDescription.mapping, finalResource);
                        if (updateQuery.parameters.length === 0) {
                            callback(new VError('Must have at least one value for creating an update string.'));
                            return;
                        }

                        cassandra.execute({
                            query: updateQuery.query,
                            parameters: updateQuery.parameters,
                            hints: updateQuery.hints,
                            //query: queryString,
                            callback: function (err) {
                                if (err !== null) {
                                    callback(err);
                                } else {
                                    // We need to add the ID back in
                                    callback(null, _.extend(finalResource, {id: id}));
                                }
                            }
                        });
                    }
                });
            }
        });
};

/**
 *
 * @param find
 * @param resourceDescription
 * @param id
 * @param callback
 */
exports.delete = function (find, resourceDescription, id, callback) {
    var resource;
    find({id: id}, null,
        function (t) {
            resource = t;
        },
        function (err, rowCount) {
            if (err) {
                callback(err);
            } else if (rowCount !== 1) {
                callback(new VError('%s %s does not exist (%s results found)', resourceDescription.tableName, id, rowCount));
            } else {
                cassandra.execute({
                    query: common.createDeleteString(resourceDescription.tableName, id),
                    callback: function (err) {
                        if (err) {
                            callback(err);
                        } else {
                            callback(null, resource);
                        }
                    }
                });
            }
        });
};

