var _ = require('underscore')._;
var VError = require('verror');
var Joi = require('joi');

var defaultSource = {
    type: 'manual',
    createTime: '', // Overwritten in pre
    algorithm: 'manual',
    parameters: {}
};

function checkSource(source) {
    var sourceTypes = ['manual', 'auto'];
    if (!_.isObject(source)) {
        return new VError('source must be an object');
    } else if (!_.has(source, 'type')) {
        return new VError('source must have a type field');
    } else if (_.indexOf(sourceTypes, source.type) === -1) {
        return new VError('source type must be one of %s', sourceTypes.join(','));
    }
}


function createRestrictedObject(inputModel, required, optional) {
    return _.extend(
        _.reduce(_.pick(model, required), function (memo, value, key) {
            memo[key] = value.required();
            return memo;
        }, {}),
        _.reduce(_.pick(model, required), function (memo, value, key) {
            memo[key] = value.optional();
            return memo;
        }, {})
    );
}

var model = {
    id: Joi.string(), //routeHelp.idValidator,
    startTime: Joi.number().description('The event start time'),
    endTime: Joi.number(),
    datasetId: Joi.string(), //routeHelp.idValidator,
    type: Joi.string().description('The event type, free form string'),
    summaryStatistics: Joi.object().description('Statistics that describe this event'),
    source: Joi.object().description('information about the source that created this event')
};

var createModel = createRestrictedObject(model,
    ['id', 'startTime', 'endTime', 'datasetId', 'type'],
    ['source']
);


module.exports = {
    name: 'event',
    tableName: 'event',


    model: Joi.object(model).options({
        className: 'event'
    }),
    createModel: Joi.object(model).options({
        className: 'create-event'
    }),

    mapping: [
        {
            cassandraKey: 'id',
            cassandraType: 'uuid',
            jsKey: 'id',
            jsType: 'string'
        },
        {
            cassandraKey: 'start_time',
            cassandraType: 'timestamp',
            jsKey: 'startTime',
            jsType: 'timestamp'
        },
        {
            cassandraKey: 'end_time',
            cassandraType: 'timestamp',
            jsKey: 'endTime',
            jsType: 'timestamp'

        },
        {
            cassandraKey: 'type',
            cassandraType: 'varchar',
            jsKey: 'type',
            jsType: 'string'
        },
        {
            cassandraKey: 'dataset',
            cassandraType: 'uuid',
            jsKey: 'datasetId',
            jsType: 'string',
        },
        {
            cassandraKey: 'source',
            cassandraType: 'varchar',
            jsKey: 'source',
            jsType: 'object'
        },
        {
            cassandraKey: 'summary_statistics',
            cassandraType: 'varchar',
            jsKey: 'summaryStatistics',
            jsType: 'object'
        }
    ],

    checkResource: function (event, callback) {


        if (event.startTime >= event.endTime) {
            callback(new VError('event startTime %s is greater than or equal to event endTime %s', event.startTime, event.endTime));
            return;
        }

        var sourceError = checkSource(event.source);
        if (sourceError) {
            callback(sourceError);
            return;
        }
        callback(null);

        /*
         // TODO(SRLM): This code is waiting until the dataset resource is completed.
         var dataset;
         resource.dataset.find({id: event.datasetId}, null,
         function (foundDataset) {
         // Store it here so that we don't have to worry about calling callback multiple times
         dataset = foundDataset;
         },
         function (err, rowCount) {
         if (err) {
         callback(err);
         }else if(rowCount !== 1){
         callback(new VError('No dataset match (%s)', rowCount);
         } else if (event.startTime < dataset.startTime) {
         callback(new VError('Event startTime %s is less than dataset start time %s', event.startTime, event.endTime));
         } else if (event.endTime > dataset.endTime) {
         callback(new VError('Event endTime %s is more than dataset end time %s', event.endTime, dataset.endTime));
         } else {
         callback(null);
         }
         });
         */
    },


    expand: function (parameters, event, callback) {
        callback(null, event);
    },

    populateDefaults: function (newEvent) {
        // Allow for a default source on new events
        if (typeof newEvent.source === 'undefined') {
            newEvent.source = defaultSource;
            newEvent.source.createTime = (new Date()).getTime();
        }

    },
    populateOnCreate: function (newEvent) {
        // Fill in the extras
        newEvent.summaryStatistics = {};
    }
};

// Testing exports
//exports.checkSource = checkSource;