var _ = require('underscore')._;
var VError = require('verror');
var Joi = require('joi');
var validators = require('./validators');

var eventSource = Joi.object({
    type: Joi.string().valid(['manual', 'auto']).default('auto').description('The type of the entity that made this event'),
    createTime: validators.timestamp, // This is required on result, but not on input.
    algorithm: Joi.string().description('the name of the algorithm that generated this event, if applicable'),
    parameters: Joi.object().description('the algorithm specific parameters')
}).description('describes what created this event').options({className: 'eventSource'});


var model = {
    id: validators.id,
    startTime: validators.timestamp,
    endTime: validators.timestamp,
    datasetId: validators.id,
    type: Joi.string().description('The event type, free form string'),
    summaryStatistics: validators.summaryStatistics,
    source: eventSource
};


var resourceName = 'event';
var resources; // Dynamically filled with links to the other resources.

module.exports = {
    name: resourceName,
    tableName: 'event',

    models: {
        model: model,
        create: Joi.object({
            startTime: model.startTime.required(),
            endTime: model.endTime.required(),
            type: model.type.required(),
            datasetId: model.datasetId.required(),
            source: model.source.required()
        }).options({className: resourceName + '.create'}),
        update: Joi.object({
            startTime: model.startTime,
            endTime: model.endTime,
            type: model.type,
            datasetId: model.datasetId,
            source: model.source
        }).options({className: resourceName + '.update'}),
        resultModel: Joi.object({
            id: model.id.required(),
            startTime: model.startTime.required(),
            endTime: model.endTime.required(),
            type: model.type.required(),
            datasetId: model.datasetId.required(),
            source: model.source.required(),
            summaryStatistics: model.summaryStatistics.required()
        }).options({className: resourceName}),
        search: {
            'id': validators.multiCSV(model.id),
            'startTime': model.startTime,
            'startTime.gt': model.startTime.description('Select events whose timestamp is greater than'),
            'startTime.lt': model.startTime.description('Select events whose timestamp is less than'),
            'endTime': model.endTime,
            'endTime.gt': model.endTime,
            'endTime.lt': model.endTime,
            'datasetId': model.datasetId,
            'type': model.type
        }
    },

    model: Joi.object(model).options({
        className: 'event'
    }),
    createModel: Joi.object(model).options({
        className: 'create-event'
    }),

    mapping: [
        {
            cassandraKey: 'id',
            cassandraType: 'uuid',
            jsKey: 'id',
            jsType: 'string'
        },
        {
            cassandraKey: 'start_time',
            cassandraType: 'timestamp',
            jsKey: 'startTime',
            jsType: 'timestamp'
        },
        {
            cassandraKey: 'end_time',
            cassandraType: 'timestamp',
            jsKey: 'endTime',
            jsType: 'timestamp'

        },
        {
            cassandraKey: 'type',
            cassandraType: 'varchar',
            jsKey: 'type',
            jsType: 'string'
        },
        {
            cassandraKey: 'dataset',
            cassandraType: 'uuid',
            jsKey: 'datasetId',
            jsType: 'string',
        },
        {
            cassandraKey: 'source',
            cassandraType: 'varchar',
            jsKey: 'source',
            jsType: 'object'
        },
        {
            cassandraKey: 'summary_statistics',
            cassandraType: 'varchar',
            jsKey: 'summaryStatistics',
            jsType: 'object'
        }
    ],

    checkResource: function (event, callback) {


        if (event.startTime >= event.endTime) {
            callback(new VError('event startTime %s is greater than or equal to event endTime %s', event.startTime, event.endTime));
            return;
        }

        var dataset;
        resources.dataset.find({id: event.datasetId}, {},
            function (dataset_) {
                dataset = dataset_;
            },
            function (err) {
                if (dataset) {
                    if (event.startTime < dataset.startTime || event.startTime > dataset.endTime) {
                        callback(new VError('Event startTime not in dataset range: ' + dataset.startTime + ' < ' + event.startTime + ' < ' + dataset.endTime));
                    } else if (event.endTime < dataset.startTime || event.endTime > dataset.endTime) {
                        callback(new VError('Event endTime not in dataset range: ' + dataset.startTime + ' < ' + event.endTime + ' < ' + dataset.endTime));
                    } else {
                        resources.panel.readPanelJSON(event.datasetId, {
                            statistics: {},
                            startTime: event.startTime,
                            endTime: event.endTime,
                            csPeriod: 10000
                        }, function (err, panelResult) {
                            if(err){
                                console.log('Event.checkResource error: ' + err);
                            }
                            event.summaryStatistics = panelResult.summaryStatistics;
                            callback(null, event);
                        });
                    }
                } else {
                    callback(new VError('Dataset ' + event.datasetId + ' not found.'));
                }

            });
        /*
         // TODO(SRLM): This code is waiting until the dataset resource is completed.
         var dataset;
         resource.dataset.find({id: event.datasetId}, null,
         function (foundDataset) {
         // Store it here so that we don't have to worry about calling callback multiple times
         dataset = foundDataset;
         },
         function (err, rowCount) {
         if (err) {
         callback(err);
         }else if(rowCount !== 1){
         callback(new VError('No dataset match (%s)', rowCount);
         } else if (event.startTime < dataset.startTime) {
         callback(new VError('Event startTime %s is less than dataset start time %s', event.startTime, event.endTime));
         } else if (event.endTime > dataset.endTime) {
         callback(new VError('Event endTime %s is more than dataset end time %s', event.endTime, dataset.endTime));
         } else {
         callback(null);
         }
         });
         */
    },
    setResources: function (resources_) {
        resources = resources_;
    },

    expand: function (parameters, event, callback) {
        callback(null, event);
    },

    populateDefaults: function (newEvent) {
        // Allow for a default source on new events


    },
    populateOnCreate: function (newEvent) {
        // Fill in the extras
        newEvent.summaryStatistics = {};
    }
};

// Testing exports
//exports.checkSource = checkSource;